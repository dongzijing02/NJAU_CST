如果调用带有默认参数的函数时缺少一个参数，则最后一个参数就作为这一参数
在C++中，混合类型表达式允许存在
表达式long(int Var)也可表示为(long)int Var
要让一个类中的所有对象具有共同的数据，请使用静态数据成员
设置虚基类的目的是消除二义性
派生类的对象可以赋值给基类的对象
派生类的对象可以初始化基类的对象
派生类的对象的地址可以赋值给指向基类的指针
普通的成员函数可以直接访问类中的静态数据成员
如果表达式 ++i*k 中的“++”和“*”都是重载的友元运算符，若采用运算符函数调用格式，则该表达式还可以表示为operator*(operator++(i),k)
后自增(i++)有参数，表示加几
类是对象的抽象，对象是类的实例，类和对象的关系是一种数据类型与变量的关系
静态成员函数没有隐含的this指针，所以，在C++程序中，静态成员函数主要用来访问静态数据成员，而不访问非静态成员
从实现的角度来讲，多态性可以划分为两类：编译时的多态性(静态多态)和运行时的多态性(动态多态)
两种代码复用方式：继承、模版或组合
析构函数可以是虚函数，构造函数不能是虚函数
假定A是一个类名，则该类的拷贝构造函数的原型说明语句为：A(const A&)
运算符重载函数可以是类的成员函数，也可以是类的友元函数，还可以是普通函数
在C++程序中，对象之间的相互通信通过调用成员函数实现
友元函数可以提高运行效率，不能继承
语句ofstream f(〃SALARY.DAT〃,ios::app｜ios::binary);的功能是建立流对象f，试图打开文件SALARY.DAT并与之连接，并且若文件存在，将文件写指针定位于文件尾；若文件不存在，建立一个新文件
内联函数在编译时是将该函数的目标代码插入每个调用该函数的地方
定义类的动态对象数组时，系统只能够自动调用该类的拷贝构造函数对其进行初始化
C++中语句const char * const p=〃hello〃；所定义的指针p和它所指的内容都不能被修改
在C++中，访问一个对象的成员所用的运算符是指针，访问一个指针所指向的对象的成员所用的运算符是this指针
C++类的组成包括数据成员和成员函数，友元不是该类的成员函数
引用是给变量取一个别名，它引入了变量的同意词
在一个类中可以对一个操作符进行多种重载
对于在类中定义的静态数据成员，在应用程序开始时创建，在类外初始化，C++中使用静态成员可以实现同一类的不同对象之间共享数据
在类中必须声明成员函数的原型，成员函数的实现部分可以写在类外
拷贝构造函数的形参必须是本类对象的引用
如果需要在被调函数运行期间，改变主调函数中实参变量的值，则函数的形参应该是引用类型或指针类型
数据成员的定义形式与一般常变量的定义形式相同，只不过常数据成员的定义必须出现在类体中，说明常成员函数时，字const写在成员函数的函数的参数表和函数体之间，常成员包含常数据成员和常成员函数两种，常数据成员必须初始化，在定义时不能直接初始化，在构造函数初始化列表进行初始化，且不能被更新，通过一个常对象只能调用它的常成员函数，不能调用其他成员函数，常数据成员不是必须是共有的
“<<插入算符，“>>"称作提取运算符
cout.fill('*'); cout.width(6); cout.fill('#');  cout << 123 << endl; 	###123
可以作为类AA构造函数的是AA(int)。AA(int)const不行
要实现动态联编，必须通过对象指针调用虚函数
面向对象程序设计有四个主要特点，即抽象、封装、_继承和多态性____
派生类中的成员不能直接访问基类中的私有成员
用流对象的成员函数控制输出格式时，用于设置字段宽度的流成员函数的名称是width，与之作用相同的控制符名称是setw
下列关于C++标识符的命名不合法的是   （C  与C#一样）A. Pad B. name_1 C. A#bc D. _a12
函数重载时，编译系统会根据形参的类型或形参的个数来区分。与返回类型无关
静态成员（static）属于__类__ ，而不属于__任何一个对象__ ，它被同一个类的所有对象共享，是对象的成员(不是数据成员)
重载运算符的含义必须清楚，不能有二义性
C++的I/O是以 字节流 的形式实现的，每个C++编译系统都带有一个面向对象的输入/输出软件包，这就是  I/O流类库
允许将一个声明为指向基类的指针指向其公有派生类的对象，但是不能将一个声明为指向派生类对象的指针指向其基类的一个对象
声明为指向基类对象的指针，当其指向公有派生类对象时，只能用它来直接访问派生类中从基类继承来的成员，而不能直接访问公有派生类中定义的成员
#include <iostream.h>#include <iomanip.h>void main(){
int kk=1234;cout<<setfill(‘*’)<<setw(6)<<kk<<endl;cout<<kk<<endl;}
以上程序的运行结果是**1234 1234
假定类AB中有一个公有属性的静态数据成员bb，在类外不通过对象名访问该成员bb的写法为AA::bb
友元函数声明在类内，说明(定义)在类外
赋值兼容规则是指在需要基类对象的任何地方都可以使用公有派生类对象来替代
运用运算符delete删除一个动态对象时，系统首先为该动态对象调用析构函数，再释放其占用的内存
析构函数可以是虚函数，构造函数不能
不能重载的符号："."	"::"	"?:"	"*"	"#"
模板的使用实际上是将类模板实例化成一个类
类的静态成员分为静态成员函数和静态数据成员
运算符重载要求保持原来的操作数个数、优先级、结合性、语法结构                     
通过关键字template可以声明模板，通过关键字class/typename指定函数模板的类型参数，有几个类型参数就有几个类型关键字
用户自定义数据类型：类、结构体、Union（共用体）、枚举、Typedef定义的类型
C++中可以用的原始数据类型为： 整数、字符、布尔型、浮点、双浮点数、void、宽字符 1
派生数据类型：功能(函数？)、数组、指针、引用
构造函数 ，是一种特殊的方法。 主要用来在创建对象时初始化对象
析构函数的作用是释放对象所占用的资源
调用拷贝构造函数：当用类的一个对象去初始化类的另一个对象时；当函数的形参是类的对象，调用函数进行形参和实参的结合时；当函数的返回值是对象，函数执行完成返回调用者时
对文件进行读写操作的5个步骤如下：
打开文件：使用相应的编程语言提供的文件操作函数，打开需要进行读写操作的文件。
读取或写入数据：使用读取或写入文件的函数来执行所需的操作。对于读取操作，可以使用读取文件的函数来从文件中读取数据。对于写入操作，可以使用写入文件的函数来将数据写入文件。
处理数据：对于读取的数据，可以进行相应的处理或操作。对于需要写入的数据，可以进行相应的准备和处理。
关闭文件：在读取或写入完成后，使用相应的函数关闭文件，释放资源并确保数据被正确写入或读取。
错误处理：在进行文件读写操作时，需要进行错误处理，以确保文件操作过程中不会出现问题，并在出现错误时进行相应的处理，比如输出错误信息或进行异常处理。
运算符重载时其函数名由operator构成A operqtor(参数)
当双目运算符重载作为成员函数时，运算符左操作数是调用成员函数的对象
继承时虚继承先构造且只构造一次





















